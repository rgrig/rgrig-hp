<!DOCTYPE html>
<html>
<head><title>thirst</title>
<script>
var BETA = 2 // how forces decrease
var EPS = 1e-6
var GAMMA = 0.07 // friction/viscosity coefficent
var IOTA = 0.1
var MARGIN = 50
var PAD = 25
var TIMESTEP = 1000 / 30

var O_r = 15
var V_len = O_r
var V_a = V_len / Math.sqrt(2)
var V_b = V_len - V_a
var V_mass = 0.01

var canvas
var twod
var imagesToLoad
var goalPicture

var state
var commands = 0
var timer

var inplay
var enemiesCount = 20

function start() {
  inplay = 0
  canvas = document.getElementById('canvas')
  twod = canvas.getContext('2d')
  imagesToLoad = 1
  goalPicture = loadImage('static/mircea-0.png')
}

function loadImage(fn) {
  var r = new Image()
  r.onload = function() {
    if (--imagesToLoad == 0) play()
  }
  r.src = fn
  return r
}

var old_resize = window.onresize
window.onresize = function (e) {
  if (old_resize) { old_resize(e) }
  size = Math.min(window.innerWidth, window.innerHeight) - 2 * PAD
  canvas.width = canvas.height = size
  assert (size > 300, 'window too small')
}

function play() {
  console.log('play')
  window.onresize()
  document.getElementById('level').innerHTML = '' + enemiesCount
  initializeState(enemiesCount)
  drawState()
  timer = window.setInterval(refresh, TIMESTEP)
  inplay = 1
}

function initializeState(n) {
  state = { x : [], y : [], vx : [], vy : [], ax : [], ay : [], n : n, ax0 : 0, ay0 : 0 }
  for (var i = 1; i <= n; ++i) {
    state.x[i] = Math.random() * 0.8 + 0.2
    state.y[i] = Math.random() * 0.8 + 0.2
    state.vx[i] = Math.random() * 0.1 - 0.05
    state.vy[i] = Math.random() * 0.1 - 0.05
    state.ax[i] = state.ay[i] = 0
  }
  state.x[0] = state.y[0] = 0.1
  state.vx[0] = state.vy[0] = 0
  state.ax[0] = state.ay[0] = 0
}

function drawState() {
  twod.fillStyle = '#eef'
  twod.fillRect(0, 0, canvas.width, canvas.height)
  twod.drawImage(goalPicture, 0.9 * canvas.width, 0, 0.1 * canvas.width, 0.1 * canvas.height)
  twod.beginPath()
  twod.arc(sx(state.x[0]), sy(state.y[0]), O_r, 0, 2 * Math.PI)
  twod.fillStyle = '#00f'
  twod.fill()
  twod.strokeStyle = '#000'
  twod.stroke()
  for (var i = 1; i <= state.n; ++i) {
    ps = [{x:V_a, y:0}, {x:-V_b, y:V_len/4}, {x:-V_b, y:-V_len/4}]
    for (var j = 0; j < ps.length; ++j) {
      ps[j] = moveToV(ps[j], state.vx[i], state.vy[i], state.x[i], state.y[i])
    }
    twod.beginPath()
    twod.moveTo(ps[0].x, ps[0].y)
    for (var j = 1; j < ps.length; ++j) {
      twod.lineTo(ps[j].x, ps[j].y)
    }
    twod.lineTo(ps[0].x, ps[0].y)
    twod.fillStyle = '#f00'
    twod.fill()
    twod.strokeStyle = '#000'
    twod.stroke()
  }
}

function moveToV(p, vx, vy, x, y) {
  alpha = 0
  if (Math.abs(vx) > EPS || Math.abs(vy) > EPS) {
    alpha = Math.atan2(vy, vx)
  }
  p = rotate(p, alpha)
  p.y = -p.y // accounts for sy's axis reversal
  p = translate(p, sx(x), sy(y))
  return p
}

// TODO: I should probably use canvas.setTransform
// see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/MatrixTransforms/MatrixTransforms.html#//apple_ref/doc/uid/TP40010542-CH10-SW1
function sx(x) { return canvas.width * x; }
function sy(y) { return canvas.height * (1-y); }
function translate(p, dx, dy) { return { x : p.x + dx, y : p.y + dy } }
function rotate(p, a) {
  return { x : p.x * Math.cos(a) - p.y * Math.sin(a), y : p.x * Math.sin(a) + p.y * Math.cos(a) }
}

function refresh() {
  if (!inplay) {
    return
  }
  dt = TIMESTEP / 1000

  for (var i = 0; i <= state.n; ++i) {
    // update positions and speeds
    state.x[i] += state.vx[i] * dt
    state.y[i] += state.vy[i] * dt
    state.vx[i] += state.ax[i] * dt
    state.vy[i] += state.ay[i] * dt

    // counteract errors
    state.x[i] = Math.max(state.x[i], 0.01)
    state.y[i] = Math.max(state.y[i], 0.01)
    state.x[i] = Math.min(state.x[i], 1 - 0.01)
    state.y[i] = Math.min(state.y[i], 1 - 0.01)
    state.vx[i] = Math.min(state.vx[i], 1)
    state.vy[i] = Math.min(state.vy[i], 1)
  }
  // engine and friction for O
  cx = ((commands >> 2) & 1) - ((commands >> 0) & 1)
  cy = ((commands >> 1) & 1) - ((commands >> 3) & 1)
  norm = Math.sqrt(cx * cx + cy * cy)
  if (norm > EPS) {
    cx /= norm
    cy /= norm
  }
  state.ax0 = cx - (cx - state.ax0) * Math.pow(IOTA, dt)
  state.ay0 = cy - (cy - state.ay0) * Math.pow(IOTA, dt)
  state.vx[0] += state.ax0 * dt - state.vx[0] * GAMMA
  state.vy[0] += state.ay0 * dt - state.vy[0] * GAMMA

  // other accelerations
  for (var i = 0; i <= state.n; ++i) {
    state.ax[i] = state.ay[i] = 0
  }
  // walls
  for (var i = 0; i <= state.n; ++i) {
    state.ax[i] += V_mass * V_mass / Math.pow(2 * state.x[i], BETA)
    state.ax[i] -= V_mass * V_mass / Math.pow(2 * (1 - state.x[i]), BETA)
    state.ay[i] += V_mass * V_mass / Math.pow(2 * state.y[i], BETA)
    state.ay[i] -= V_mass * V_mass / Math.pow(2 * (1 - state.y[i]), BETA)
  }
  // avoid each-other
  for (var i = 1; i <= state.n; ++i) {
    for (var j = 1; j <= state.n; ++j) if (j != i) {
      d = Math.sqrt(Math.pow(state.x[i] - state.x[j], 2) + Math.pow(state.y[i] - state.y[j], 2))
      a = V_mass * V_mass / Math.pow(d, BETA)
      state.ax[i] += a * (state.x[i] - state.x[j]) / d
      state.ay[i] += a * (state.y[i] - state.y[j]) / d
    }
  }
  drawState()

  // detect (simple) collisions
  if (state.x[0] > 0.9 && state.y[0] > 0.9) {
    restart('#0f0', +1)
    return
  }
  x0 = sx(state.x[0])
  y0 = sy(state.y[0])
  for (var i = 1; i <= state.n; ++i) {
    tip = moveToV({ x : V_a, y : 0 }, state.vx[i], state.vy[i], state.x[i], state.y[i])
    d = Math.sqrt(Math.pow(x0 - tip.x, 2) + Math.pow(y0 - tip.y, 2))
    if (d < O_r) {
      restart('#f00', -1)
      return
    }
  }
}

function restart(style, enemiesDelta) {
  inplay = 0
  window.clearInterval(timer)
  twod.fillStyle = style
  twod.fillRect(0, 0, canvas.width, canvas.height)
  enemiesCount = Math.max(0, enemiesCount + enemiesDelta)
  window.setTimeout(play, 2000)
}

function keydown(e) {
  if (!(37 <= e.keyCode && e.keyCode <= 40)) return
  commands |= (1 << (e.keyCode - 37))
}

function keyup(e) {
  if (!(37 <= e.keyCode && e.keyCode <= 40)) return
  commands &= ~(1 << (e.keyCode - 37))
}

function assert(b, m) {
  if (!b) console.log('INTERNAL: ' + m)
}

</script>
</head>
<center>
Designed by <a href="static/mgrig_design.jpg">Mircea Grigore</a>.
Enemies count: <span id="level"></span>.<br/>
<body onload="start()" onkeyup="keyup(event)" onkeydown="keydown(event)">
<canvas id="canvas"></canvas>
</center>
</body>
</html>
